java基础

### 1、封装继承多态
封装	封装就是隐藏对象的属性以及实现的细节，可控的对外部提供访问的方式，一般常见的就像bean、model数据集和各种工具类
继承	继承就是子类继承父类的特性和行为，让子类能够拥有父类的方法，使子类实例能够和父类有相同的行为
多态	多态就是同一种行为不同的表现形态，就像猫狗都是动物，但是猫吃鱼狗吃骨头。（增加拓展性，方面对所有类对象进行通用处理）

### 1、多态是运行时还是编译时
准确的来说是运行时多态
编译时多态主要指的是函数的重载，举个例子一个类a，他有很多个f方法，但是每个的参数都不一样，所以a实例调用f方法时，编译器会查看传入值类型，对应的去选择不同的方法
运行时多态主要运用到的动态绑定，运行时动态确定是哪个方法。比如说一个a类有多个不同子类，每个子类都有f方法，当声明一个a的对象a，用不同子类去进行不同的实例化，在对象a调用f方法时，就会去动态判断是哪个子类的哪个方法，这种多态才是严格意义上的多态

### 2、编程思想
用计算机解决人们实际问题的思维方式

### 3、面向对象编程思想（三大特性 封装继承多态）
面向对象编程的主要思想就是把构成问题的各个事物拆分成对象，通过建立对象去描述解决过程中的步骤和行为。以对象为基本单位，将程序和数据封装在对象中，通过不同的使用组合解决问题。

### 4、i++和++i的区别
++i是先加后用 i++是先用后加

### 5、java对象的四种引用
java核心“万物皆对象” 对象就是某个类的实例
强引用 对象创建的时候就给对象赋值，强引用的变量永远不会被回收，即使会抛出oom
软引用 如果一个对象具有软引用，内存足够，gc就不会回收（多用于网页缓存图片缓存，能防止内存泄露增加程序的健壮性）
弱引用 用来描述非必须对象，当虚拟器进行回收时不管内存够不够 都会回收关联的对象
虚引用 不影响对象的生命周期，java中用PhantomReference类表示。对象与虚引用关联就跟没有引用关联一样，随时都可能被回收

### 6、对象判断
类型判断用instanceof
精确判断是否具体一个类的实例用equals

### 7、输入整数转换成二进制计算1出现的次数
String binaryString = Integer.toBinaryString(value);//转二进制
int count = 0;
Pattern p = Pattern.compile(findText);
Matcher m = p.matcher(srcText);
while (m.find()) {
    count++;
}
Pattern是一个正则表达式经编译后的表现模式，通过Matcher状态机器依据Pattern对象作为匹配模式对字符串进行匹配检查

### 8、线程和进程的区别
线程 系统中运行的一个应用程序，专业点说就是程序执行时的一个实例
进程 是一个具有独立功能的程序关于一个数据集合的一次运行活动，通俗点说就是一个程序的执行过程就是进程（进程是基本分配单元也是基本执行单元）
线程的划分尺度小于进程
进程在执行过程中拥有独立内存单元，线程共享内存
多线程在于一个应用程序中，有多个执行部分可以同时执行，不过操作系统并没有将多个线程看作独立的应用来实现进程的调度和管理分配资源

### 9、sqlite特性
轻量
跨平台
隔离性，全部在一个文件夹系统
多语言支持，支持众多编程语言
安全，通过独占性和共享锁来实现独立事物的处理，读取可以多个进程同时，写入只能一个写入

### 10、同步锁和死锁
同步锁就是一段被一把锁锁住的代码块运行时只能被一个线程运行，其他线程需要运行时得等上一个线程运行完才可运行
死锁就是多把锁同时被锁住，两个都不释放导致线程都在等对方释放出资源造成线程阻塞，举个例子就是同一条独木桥（相当于需要的资源），左边一个人（相当于线程a）走了一半，同时右边一个人（相当于线程b）也走了一半，两边都在等对方推好走完独木桥，但是两个都不退，所以两人就被堵死在独木桥上
代码例子：两把锁对象a、b，两个runnable c、d，c中先锁a再锁b，d中锁b再锁c，两个线程同时运行，c锁住a的同时b被d锁住，然后c等b，d等a，两不释放就死锁了

### 11、异步和同步
异步就是发送请求需要等待时间才能拿到结果但是不需要等待结果随时可以发送下一个请求
同步就是发送一个请求需要等待返回再进行下一个请求
异步好处是能够提高效率而同步能避免出现死锁，数据读乱

### 12、gc回收
gc就是垃圾收集的意思，内存处理是在编程中容易出问题的地方，有时候忘记活着错误的内存回收会导致程序不稳定，所以java就有了垃圾回收的功能，可以自动的不定期进行回收，释放无用的空间，同时也可以手动调用system。gc主动回收

原理 创建对象时，gc会开始监控该对象的地址大小以及使用情况，然后gc通过堆内的对象管理确定对象的状态，那些可达哪些不可达，确定对象不可达之后就会触发gc

堆heap 存放对象实例和数组，全剧共享的
栈stack 虚拟机栈存放基本类型以及对象的引用，私有线程
方法区 class被加载之后的一些信息，比如说常量静态常量这些

